"""This is a text based game to practice basic maths skills"""

#importing the random module for random number generation the Game classes
import random

#Initialising the User class where information is stored about game settings and score
class User:
    def __init__(self):
        self.total_count=0
        self.total_incorrect=0
        self.count=0
        self.incorrect=0
        self.tables=''
        self.theme=''
        self.last_answer=''
        self.last_theme=''
        self.corrections_list=[]

#Function to update the score and review any incorrectly answered questions and printing the accuracy score of a completed round
    def update_score(self):
        if self.incorrect>0:
            if input(
                'Would you like to review? (Y\\N)'
                ).upper() == 'Y':
                for x in range(len(self.corrections_list)):
                    Game.check(*self.corrections_list[x])
        if self.count>0:
            print (
                f'\n You answered {self.count} correctly with {self.accuracy*100:.0f}% accuracy. Good job!\n'
                )
        self.total_count+=self.count
        self.count=0
        self.total_incorrect+=self.incorrect
        self.incorrect=0
        self.corrections_list=[]

# function to update the score counter, tracking how many questions have been answered so far; used in accuracy calculations elsewhere
    def add_count(self):
        self.count+=1

# function also related to score and accuracy, adding the incorrectly answered problem to a list to be reviewed later by User.update_score()
    def add_incorrect(self, answer, a, b, sign):
        self.incorrect+=1
        if [answer, a, b, sign] not in self.corrections_list:
            self.corrections_list.append([answer, a, b, sign])

# tracker to ensure the random mode doesn't give a question from the same mode twice
    def set_last_theme(self):
        self.last_theme=self.theme

# accuracy property calculates itself as needed from the stored variables, handling a case where the user exits without answering any questions
    @property
    def accuracy(self):
        try:
            return (self.count-self.incorrect)/self.count
        except ZeroDivisionError as e:
            return 0

#as above for the total count, used below
    @property
    def total_accuracy(self):
        try:
            return (self.total_count-self.total_incorrect)/self.total_count
        except ZeroDivisionError as e:
            return 0

#defining string method to print a custom message used on program exit to display the total score for the session
#displays a custom message if no games were played
    def __str__(self):
        if self.total_count==0:
            raise NoGameException(
                'No games played, no score available'
                )
        else:
            return f'\n In total, you answered {self.total_count} questions correctly with {self.total_accuracy*100:.0f}% accuracy. Good job!\n Thanks for playing!'

#custom exception class for no games played
class NoGameException(Exception):
    pass     

#game class, where game functions and generation takes place
#also houses the menu system    
class Game:

#initialising an instance of the User class
    player=User()

#establishing a dictionary of games    
    def games(): 
        return {
            'A': addition.generate, 
            'S': subtraction.generate, 
            'D': division.generate, 
            'M': multiplication.generate,
        }

#a multipurpose function to check the input of the user against the answer to the problem generated
    def check(answer, a, b, sign):
        #this is where the problem generated by the game is presented to the user to solve
        user_input=input(f' \n{a:>3}\n{sign}{b:>3} =')
        while user_input!=answer:
            try:
                 user_input=int(user_input)
            except (ValueError) as e:
                #handling menu operations, the user can always press q to exit to the menu 
                if user_input.upper()=='Q':
                    #return False here will break the loop the function was called within exiting this mode of the program
                    return False
                #handling unidentified inputs, giving the user another opportunity to answer the problem
                user_input=input(
                            '\n Oops! Try again:'
                    )
                continue
            if user_input!=answer:
                #storing problem for review later
                Game.player.add_incorrect(answer, a, b, sign)
                user_input=input(
                    '\n Not quite, try again: '
                    )
        #storing answer to ensure no repeat problems
        Game.player.last_answer=answer
        print(
            '\n Good Job!'
            )
        Game.player.add_count()
        return True

    #this function prints the score when the player exits the program
    def quit():
        try:
            print(
                Game.player
                )
        #printing a custom message if no questions were answered
        except NoGameException as e:
            print(
                'Goodbye!'
                )

    #this is the menu loop that handles the different modes of the program        
    def menu():
        while True:
            try:
                Game.player.theme=input(
                    'Which operation you like to practice? (enter Q to exit)\n(A)ddition, (S)ubtraction, (D)ivision, (M)ultiplication or (R)andom: '
                    ).upper()
                #it also allows the user to exit the program
                if Game.player.theme=='Q':
                    Game.quit()
                    break
                #for certain game modes additional options are available
                if Game.player.theme in ['M', 'D', 'R']:
                    #here the player chooses the times tables they would like to recieve questions from
                    #any input other than a number will cause the game to choose random tables for each question
                    Game.player.tables=input(
                        'Which tables would you like to practice? (R for random)'
                        ).upper()
                #the random setting sets 10 questions while ensuring the question types are not repeated
                if Game.player.theme=='R':
                    for x in range(10):
                        Game.player.set_last_theme()
                        if randomise.generate()==False:
                            break
                #otherwise 10 questions of the desired type are set from the set of tables specified above
                elif Game.player.theme in Game.games():
                    for x in range(10):
                        game_start=Game.games()[Game.player.theme]
                        if game_start()==False:
                            break
                elif Game.player.theme=='F':
                    Game.fibonacci()
                    continue
                elif Game.player.theme=='Z':
                    Game.sequencer()
                #if none of the if statements are triggered the game will say it hasn't recieved a valid input and start again      
                else:
                    print("Not sure what you mean!")
                    continue
            #if the user needs to terminate the process, they will recieve this message
            except KeyboardInterrupt as e:
                print(
                    '\nThat\'s enough for now.')
                break
            #the game will always try to update the score at the end of a round
            #nothing will be printed here on menu exit, since no games were played
            finally: 
                Game.player.update_score()

# secret feature: fibonacci sequence generator; (F) to start
    def fibonacci():
        f_sequence=[1,1]
        while True:
            f_sequence_length=input('How many figures of the Fibonacci sequence would you like?').upper()
            try:
                f_sequence_length=int(f_sequence_length)
            except ValueError as e:
                if f_sequence_length=='Q':
                    break
                print('Please specify a numer.')
                continue
            for x in range(f_sequence_length):
                f_sequence.append(sum(f_sequence[-2:]))
            print(f_sequence)
            break

# secret feature: guess the next number in the sequence, (Z) to start
    def sequencer():
        sequence=[]
        sequence.append(random.randint(1,5))
        sequence.append(random.randint(1,5))
        a=random.randint(-3,-2)
        c=random.randint(1,2)
        for x in range(10):
            sequence.append(sum(sequence[a::c]))
        while True:
            user_input=input(f'What is the next number in this sequence: {sequence[2:8]}')
            try:
                user_input=int(user_input)
            except ValueError as e:
                if user_input.upper()=='Q':
                    print(f'Sorry the answer was {sequence[8]}')
                    break
                else:
                    print('Oops, try again!')
                    continue
            except AttributeError as e:
                print(f'Sorry the answer was {sequence[8]}')
            if user_input==sequence[8]:
                print('Good job!')
                break

#this is a parent function for the generation of problems
#it handles whether or not the user has selected a specific set of tables to work from
    def generator():
        b=Game.player.tables
        try:
            b=int(Game.player.tables)
        except(ValueError):
            b=random.randint(2, 12)
        return b
    
#here the child classes inherit the check function and each have their own generation function
#the addition class generates two numbers between 1 and 100
class addition(Game):
    def generate():
        a=random.randint(1, 100)
        b=random.randint(1, 100)
        answer=a+b
        return addition.check(answer, a, b, '+')

#the subtraction class generates a number between 1 and 100 and another number between that number and 100
#this ensures no negative answers
class subtraction(Game):        
    def generate():
        b=random.randint(1, 100)
        a=random.randint(b, 100)
        answer=a-b
        return subtraction.check(answer, a, b, '-')

#the division class checks the user settings and then creates a problem from two numbers between 2 and 12
# it generates the answer by multiplying the generated numbers together
# this uses less resources than trying to generate an answer first
class division(Game):
    def generate():
        b = division.generator()
        a=b*random.randint(2,12)
        #it also checks to make sure it is not asking the same question twice in a row
        while a/b==Game.player.last_answer and a!=b:
            a=b*random.randint(2,12)
        answer=a/b
        return division.check(answer, a, b, '/')

#the multiplication generator is a little more straightforward but still makes the same checks
class multiplication(Game):      
    def generate():
        b = multiplication.generator()
        a=random.randint(2,12)
        while a*b==Game.player.last_answer:
            a=random.randint(1,12)
        answer=a*b
        return multiplication.check(answer, a, b, '*')

#the randomise mode chooses a theme from the dictionary  
#it also ensures the same theme is not chosen two times in a row           
class randomise(Game):        
    def generate():
        while Game.player.theme==Game.player.last_theme:
            Game.player.theme=random.choice(list(Game.games().values()))
        if Game.player.theme() == False:
            return False

# this will start the program from the menu as long as the code is not initialized from an import statement
if __name__=='__main__':
    Game.menu()